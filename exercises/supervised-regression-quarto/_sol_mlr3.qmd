(@) Model classes representing a certain **hypothesis** are stored in `learner` objects. Before training them on actual
data, they just contain information on the functional form of $f$. Once a learner has been trained we can examine
the parameters of the resulting model. The empirical **risk** can be assessed after training by several performance
measures (e.g., based on $L2$ loss). **Optimization** happens rather implicitly as `mlr3` only acts as a wrapper for
existing implementations and calls package-specific optimization procedures
